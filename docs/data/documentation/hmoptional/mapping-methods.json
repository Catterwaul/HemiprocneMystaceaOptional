{"kind":"article","primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"inlineContent":[{"type":"text","text":"Unlike with "},{"code":"Result","type":"codeVoice"},{"type":"text","text":", the standard library supports "},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/optional#Transforming-an-Optional-Value","isActive":true,"type":"reference"},{"type":"text","text":" to an adequate level. No additional code is required by this package."}],"type":"paragraph"},{"inlineContent":[{"text":"But, it is useful to understand how the mapping possibilities for ","type":"text"},{"code":"Optional","type":"codeVoice"},{"type":"text","text":" differ from "},{"code":"Result","type":"codeVoice"},{"type":"text","text":", as documented in "},{"identifier":"https:\/\/catterwaul.github.io\/HemiprocneMystaceaResult\/documentation\/hmresult\/mapping-methods","isActive":true,"type":"reference"},{"type":"text","text":"."}],"type":"paragraph"},{"text":"flatMap","level":3,"type":"heading","anchor":"flatMap"},{"inlineContent":[{"type":"text","text":"Unlike with "},{"type":"codeVoice","code":"Result"},{"text":", ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/optional\/flatmap(_:)","type":"reference","isActive":true},{"text":" is implemented perfectly in the standard library.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"reference","identifier":"https:\/\/docs.swift.org\/swift-book\/documentation\/the-swift-programming-language\/optionalchaining\/","isActive":true},{"type":"text","text":" represents a specific subset of "},{"type":"codeVoice","code":"flatMap"},{"type":"text","text":"—the most common use case. It would be great if other “throwing property wrappers” could use chaining as well, but is of course not supported."}],"type":"paragraph"},{"syntax":"swift","code":["let animals: Optional = \"🦁🐯🐻\"","var first: Character? = animals.flatMap(\\.first)","first = animals?.first \/\/ Same as above."],"type":"codeListing"},{"text":"flatMapAndMergeError","level":3,"type":"heading","anchor":"flatMapAndMergeError"},{"inlineContent":[{"type":"text","text":"In "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/Catterwaul\/Thrappture"},{"type":"text","text":", we’ve defined "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":"’s "},{"type":"codeVoice","code":"Failure"},{"type":"text","text":" type as "},{"type":"text","text":"`Nil`"},{"type":"text","text":". But regardless of how you model it,"},{"type":"text","text":" "},{"type":"codeVoice","code":"Optional.none"},{"type":"text","text":" is generic over "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":" itself. That means that the only way for two "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":" types to “share their failure type”, is for the "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":"s to actually be of the exact same type."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"So, "},{"type":"codeVoice","code":"flatMapAndMergeError"},{"type":"text","text":" would be simplifiable to the following. We haven’t felt a need to include this in this package, but are open to doing so if you could convince us of its usefulness."}],"type":"paragraph"},{"syntax":"swift","code":["func flatMapAndMergeError(","  _ transform: (Wrapped) throws(Nil) -> Self",") -> Self {","  try? transform(get())","}"],"type":"codeListing"},{"text":"map","level":3,"type":"heading","anchor":"map"},{"inlineContent":[{"text":"Again, unlike with ","type":"text"},{"type":"codeVoice","code":"Result"},{"text":", ","type":"text"},{"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/optional\/map(_:)","isActive":true},{"text":" is implemented perfectly in the standard library.","type":"text"}],"type":"paragraph"},{"text":"mapAndMergeError","level":3,"type":"heading","anchor":"mapAndMergeError"},{"inlineContent":[{"text":"Because Swift allows for values to be implicitly promoted to optionals, the body of ","type":"text"},{"code":"Optional.mapAndMergeError","type":"codeVoice"},{"text":" would be exactly the same as ","type":"text"},{"code":"Optional.flatMapAndMergeError","type":"codeVoice"},{"text":"‘s’, above. So we’re not including this method either.","type":"text"}],"type":"paragraph"},{"text":"flatMapFailure","level":4,"type":"heading","anchor":"flatMapFailure"},{"inlineContent":[{"type":"codeVoice","code":"Optional"},{"text":" cannot make use of this by itself, because its ","type":"text"},{"type":"codeVoice","code":"Failure"},{"text":" type always matches its ","type":"text"},{"type":"codeVoice","code":"Wrapped"},{"text":" type. I.e. transforming one ","type":"text"},{"type":"codeVoice","code":"Optional.Nil"},{"text":" to another is the same as transforming one ","type":"text"},{"type":"codeVoice","code":"Optional"},{"text":" to another. That requires a ","type":"text"},{"type":"codeVoice","code":"flatMap"},{"text":". And, a transformation of ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":", if you want to do anything other than change one ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":" into ","type":"text"},{"type":"codeVoice","code":"another"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You can’t do much meaningful using "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" as an input, but there is syntactical sugar available to “transform it”—the "},{"type":"reference","identifier":"https:\/\/docs.swift.org\/swift-book\/documentation\/the-swift-programming-language\/basicoperators\/#Nil-Coalescing-Operator","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"A combination of ","type":"text"},{"code":"flatMap","type":"codeVoice"},{"text":", nil-coalescing, and implicit promotion to optionals is not only about the closest you can get to ","type":"text"},{"code":"flatMapError","type":"codeVoice"},{"text":" with an ","type":"text"},{"code":"Optional","type":"codeVoice"},{"text":"—it’s also a practical usage of the “general transformation” methods that start off ","type":"text"},{"isActive":true,"overridingTitleInlineContent":[{"type":"text","text":"the Result mapping article"}],"identifier":"https:\/\/catterwaul.github.io\/HemiprocneMystaceaResult\/documentation\/hmresult\/mapping-methods","type":"reference","overridingTitle":"the Result mapping article"},{"text":"—just with a different spelling.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let characters: Optional = \"🦁🐯🐻\"","let character: Character? = characters.flatMap { \"\\($0)👧🏻👠🐒🪽\".randomElement() } ?? \"🧙‍♀️\""],"type":"codeListing"},{"text":"mapFailureToSuccess","level":4,"type":"heading","anchor":"mapFailureToSuccess"},{"inlineContent":[{"text":"This is nil-coalescing, specifically when the result is non-optional.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Important to note:","type":"text"}]}],"type":"emphasis"},{"text":" while nil-coalescing allows for completely removing ","type":"text"},{"code":"Optional","type":"codeVoice"},{"text":" wrappers, you’ll sometimes need to use ","type":"text"},{"code":"flatMap","type":"codeVoice"},{"text":", instead of ","type":"text"},{"code":"map","type":"codeVoice"},{"text":", to flatten optionality down to one level of wrapping, first.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let characters: Optional = \"🦁🐯🐻👧🏻👠🐒🪽\"","characters?.randomElement() ?? \"🧙‍♀️\"               \/\/ Character","characters.flatMap { $0.randomElement() } ?? \"🧙‍♀️\" \/\/ Character","characters.map { $0.randomElement() } ?? \"🧙‍♀️\"     \/\/ Character?"],"type":"codeListing"},{"text":"mapFailureToSuccessAndErrorToFailure","level":4,"type":"heading","anchor":"mapFailureToSuccessAndErrorToFailure"},{"inlineContent":[{"type":"text","text":"This is nil-coalescing, when the argument on the right of the "},{"type":"codeVoice","code":"??"},{"type":"text","text":" is also optional."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Because "},{"type":"codeVoice","code":"Success"},{"type":"text","text":" can’t change, and "},{"type":"codeVoice","code":"Failure"},{"type":"text","text":" is tied to "},{"type":"codeVoice","code":"Success"},{"type":"text","text":", for "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":", "},{"type":"codeVoice","code":"Failure"},{"type":"text","text":" can’t change either."}],"type":"paragraph"},{"syntax":"swift","code":["let characters: Optional = \"🦁🐯🐻👧🏻👠🐒🪽\"","let character: Character? = \"🧙‍♀️\"","characters?.randomElement() ?? character  \/\/ Character?"],"type":"codeListing"}]}],"variants":[{"paths":["\/documentation\/hmoptional\/mapping-methods"],"traits":[{"interfaceLanguage":"swift"}]}],"hierarchy":{"paths":[["doc:\/\/HMOptional\/documentation\/HMOptional"]]},"identifier":{"url":"doc:\/\/HMOptional\/documentation\/HMOptional\/Mapping-Methods","interfaceLanguage":"swift"},"seeAlsoSections":[{"identifiers":["doc:\/\/HMOptional\/documentation\/HMOptional\/Swift\/Optional"],"generated":true}],"sections":[],"schemaVersion":{"patch":0,"minor":3,"major":0},"metadata":{"roleHeading":"Article","role":"article","title":"Mapping Methods","modules":[{"name":"HMOptional"}]},"references":{"doc://HMOptional/documentation/HMOptional":{"url":"\/documentation\/hmoptional","type":"topic","role":"collection","identifier":"doc:\/\/HMOptional\/documentation\/HMOptional","kind":"symbol","title":"HMOptional","abstract":[{"type":"text","text":"Extended functionality for "},{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/optional"},{"type":"text","text":"."}]},"https://developer.apple.com/documentation/swift/optional/map(_:)":{"title":"Optional.map","type":"link","titleInlineContent":[{"code":"Optional.map","type":"codeVoice"}],"url":"https:\/\/developer.apple.com\/documentation\/swift\/optional\/map(_:)","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/optional\/map(_:)"},"https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#Nil-Coalescing-Operator":{"title":"nil-coalescing operator","identifier":"https:\/\/docs.swift.org\/swift-book\/documentation\/the-swift-programming-language\/basicoperators\/#Nil-Coalescing-Operator","titleInlineContent":[{"text":"nil-coalescing operator","type":"text"}],"type":"link","url":"https:\/\/docs.swift.org\/swift-book\/documentation\/the-swift-programming-language\/basicoperators\/#Nil-Coalescing-Operator"},"https://catterwaul.github.io/HemiprocneMystaceaResult/documentation/hmresult/mapping-methods":{"title":"HemiprocneMystaceaResult","type":"link","titleInlineContent":[{"text":"HemiprocneMystaceaResult","type":"text"}],"url":"https:\/\/catterwaul.github.io\/HemiprocneMystaceaResult\/documentation\/hmresult\/mapping-methods","identifier":"https:\/\/catterwaul.github.io\/HemiprocneMystaceaResult\/documentation\/hmresult\/mapping-methods"},"https://developer.apple.com/documentation/swift/optional":{"title":"Optional","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/optional","titleInlineContent":[{"text":"Optional","type":"text"}],"type":"link","url":"https:\/\/developer.apple.com\/documentation\/swift\/optional"},"doc://HMOptional/documentation/HMOptional/Swift/Optional":{"type":"topic","navigatorTitle":[{"kind":"identifier","text":"Optional"}],"kind":"symbol","identifier":"doc:\/\/HMOptional\/documentation\/HMOptional\/Swift\/Optional","role":"symbol","title":"Optional","fragments":[{"text":"extension","kind":"keyword"},{"text":" ","kind":"text"},{"preciseIdentifier":"s:Sq","text":"Optional","kind":"identifier"}],"abstract":[],"url":"\/documentation\/hmoptional\/swift\/optional"},"https://github.com/Catterwaul/Thrappture":{"title":"Thrappture","type":"link","titleInlineContent":[{"text":"Thrappture","type":"text"}],"url":"https:\/\/github.com\/Catterwaul\/Thrappture","identifier":"https:\/\/github.com\/Catterwaul\/Thrappture"},"https://developer.apple.com/documentation/swift/optional#Transforming-an-Optional-Value":{"title":"Optional mapping","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/optional#Transforming-an-Optional-Value","titleInlineContent":[{"code":"Optional","type":"codeVoice"},{"text":" mapping","type":"text"}],"type":"link","url":"https:\/\/developer.apple.com\/documentation\/swift\/optional#Transforming-an-Optional-Value"},"https://developer.apple.com/documentation/swift/optional/flatmap(_:)":{"title":"Optional.flatMap","type":"link","titleInlineContent":[{"code":"Optional.flatMap","type":"codeVoice"}],"url":"https:\/\/developer.apple.com\/documentation\/swift\/optional\/flatmap(_:)","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/optional\/flatmap(_:)"},"https://docs.swift.org/swift-book/documentation/the-swift-programming-language/optionalchaining/":{"title":"Optional chaining","identifier":"https:\/\/docs.swift.org\/swift-book\/documentation\/the-swift-programming-language\/optionalchaining\/","titleInlineContent":[{"text":"Optional chaining","type":"text"}],"type":"link","url":"https:\/\/docs.swift.org\/swift-book\/documentation\/the-swift-programming-language\/optionalchaining\/"}}}