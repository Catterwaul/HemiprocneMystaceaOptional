{"identifier":{"url":"doc:\/\/HMOptional\/documentation\/HMOptional\/Mapping-Methods","interfaceLanguage":"swift"},"primaryContentSections":[{"kind":"content","content":[{"type":"heading","text":"Overview","anchor":"Overview","level":2},{"type":"paragraph","inlineContent":[{"text":"Unlike with ","type":"text"},{"code":"Result","type":"codeVoice"},{"type":"text","text":", the standard library supports "},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/optional#Transforming-an-Optional-Value","type":"reference","isActive":true},{"text":" to an adequate level. No additional code is required by this package.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But, it is useful to understand how the mapping possibilities for "},{"code":"Optional","type":"codeVoice"},{"type":"text","text":" differ from "},{"type":"codeVoice","code":"Result"},{"type":"text","text":", as documented in "},{"identifier":"https:\/\/catterwaul.github.io\/HemiprocneMystaceaResult\/documentation\/hmresult\/mapping-methods","isActive":true,"type":"reference"},{"type":"text","text":"."}]},{"type":"heading","text":"flatMap","level":3,"anchor":"flatMap"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Unlike with "},{"code":"Result","type":"codeVoice"},{"type":"text","text":", "},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/optional\/flatmap(_:)","isActive":true,"type":"reference"},{"text":" is implemented perfectly in the standard library.","type":"text"}]},{"inlineContent":[{"identifier":"https:\/\/docs.swift.org\/swift-book\/documentation\/the-swift-programming-language\/optionalchaining\/","type":"reference","isActive":true},{"type":"text","text":" represents a specific subset of "},{"code":"flatMap","type":"codeVoice"},{"text":"‚Äîthe most common use case. It would be great if other ‚Äú","type":"text"},{"identifier":"https:\/\/github.com\/Catterwaul\/Thrappture","type":"reference","isActive":true},{"text":"‚Äù could use chaining as well, but is of course not supported.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let animals: Optional = \"ü¶ÅüêØüêª\"","var first: Character? = animals.flatMap(\\.first)","first = animals?.first \/\/ Same as above."]},{"type":"heading","text":"flatMapAndMergeError","level":3,"anchor":"flatMapAndMergeError"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In "},{"overridingTitleInlineContent":[{"text":"Thrappture","type":"text"}],"overridingTitle":"Thrappture","identifier":"https:\/\/github.com\/Catterwaul\/Thrappture","type":"reference","isActive":true},{"type":"text","text":", we‚Äôve defined "},{"code":"Optional","type":"codeVoice"},{"type":"text","text":"‚Äôs "},{"code":"Failure","type":"codeVoice"},{"text":" type as ","type":"text"},{"text":"`Nil`","type":"text"},{"text":". But regardless of how you model it,","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"Optional.none"},{"type":"text","text":" is generic over "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":" itself. That means that the only way for two "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":" types to ‚Äúshare their failure type‚Äù, is for the "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":"s to actually be of the exact same type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So, "},{"type":"codeVoice","code":"flatMapAndMergeError"},{"type":"text","text":" would be simplifiable to the following. We haven‚Äôt felt a need to include this in this package, but are open to doing so if you could convince us of its usefulness."}]},{"syntax":"swift","type":"codeListing","code":["func flatMapAndMergeError(","  _ transform: (Wrapped) throws(Nil) -> Self",") -> Self {","  try? transform(get())","}"]},{"level":3,"type":"heading","anchor":"map","text":"map"},{"inlineContent":[{"type":"text","text":"Again, unlike with "},{"code":"Result","type":"codeVoice"},{"type":"text","text":", "},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/optional\/map(_:)","type":"reference","isActive":true},{"text":" is implemented perfectly in the standard library.","type":"text"}],"type":"paragraph"},{"level":3,"type":"heading","anchor":"mapAndMergeError","text":"mapAndMergeError"},{"inlineContent":[{"text":"Because Swift allows for values to be implicitly promoted to optionals, the body of ","type":"text"},{"type":"codeVoice","code":"Optional.mapAndMergeError"},{"text":" would be exactly the same as ","type":"text"},{"type":"codeVoice","code":"Optional.flatMapAndMergeError"},{"text":"‚Äòs‚Äô, above. So we‚Äôre not including this method either.","type":"text"}],"type":"paragraph"},{"level":4,"type":"heading","anchor":"flatMapFailure","text":"flatMapFailure"},{"inlineContent":[{"type":"codeVoice","code":"Optional"},{"text":" cannot make use of this by itself, because its ","type":"text"},{"type":"codeVoice","code":"Failure"},{"text":" type always matches its ","type":"text"},{"type":"codeVoice","code":"Wrapped"},{"text":" type. I.e. transforming one ","type":"text"},{"type":"codeVoice","code":"Optional.Nil"},{"text":" to another is the same as transforming one ","type":"text"},{"code":"Optional","type":"codeVoice"},{"type":"text","text":" to another. That requires a "},{"type":"codeVoice","code":"flatMap"},{"type":"text","text":". And, a transformation of "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", if you want to do anything other than change one "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" into "},{"type":"codeVoice","code":"another"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You can‚Äôt do much meaningful using "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" as an input, but there is syntactical sugar available to ‚Äútransform it‚Äù‚Äîthe "},{"type":"reference","identifier":"https:\/\/docs.swift.org\/swift-book\/documentation\/the-swift-programming-language\/basicoperators\/#Nil-Coalescing-Operator","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"A combination of "},{"type":"codeVoice","code":"flatMap"},{"type":"text","text":", nil-coalescing, and implicit promotion to optionals is not only about the closest you can get to "},{"type":"codeVoice","code":"flatMapError"},{"type":"text","text":" with an "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":"‚Äîit‚Äôs also a practical usage of the ‚Äúgeneral transformation‚Äù methods that start off "},{"type":"reference","overridingTitleInlineContent":[{"text":"the Result mapping article","type":"text"}],"identifier":"https:\/\/catterwaul.github.io\/HemiprocneMystaceaResult\/documentation\/hmresult\/mapping-methods","isActive":true,"overridingTitle":"the Result mapping article"},{"type":"text","text":"‚Äîjust with a different spelling."}],"type":"paragraph"},{"code":["let characters: Optional = \"ü¶ÅüêØüêª\"","let character: Character? = characters.flatMap { \"\\($0)üëßüèªüë†üêíü™Ω\".randomElement() } ?? \"üßô‚Äç‚ôÄÔ∏è\""],"syntax":"swift","type":"codeListing"},{"level":4,"text":"mapFailureToSuccess","anchor":"mapFailureToSuccess","type":"heading"},{"inlineContent":[{"type":"text","text":"This is nil-coalescing, specifically when the result is non-optional."}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Important to note:"}]}]},{"type":"text","text":" while nil-coalescing allows for completely removing "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":" wrappers, you‚Äôll sometimes need to use "},{"type":"codeVoice","code":"flatMap"},{"type":"text","text":", instead of "},{"type":"codeVoice","code":"map"},{"type":"text","text":", to flatten optionality down to one level of wrapping, first."}],"type":"paragraph"},{"code":["let characters: Optional = \"ü¶ÅüêØüêªüëßüèªüë†üêíü™Ω\"","characters?.randomElement() ?? \"üßô‚Äç‚ôÄÔ∏è\"               \/\/ Character","characters.flatMap { $0.randomElement() } ?? \"üßô‚Äç‚ôÄÔ∏è\" \/\/ Character","characters.map { $0.randomElement() } ?? \"üßô‚Äç‚ôÄÔ∏è\"     \/\/ Character?"],"syntax":"swift","type":"codeListing"},{"level":4,"text":"mapFailureToSuccessAndErrorToFailure","anchor":"mapFailureToSuccessAndErrorToFailure","type":"heading"},{"inlineContent":[{"type":"text","text":"This is nil-coalescing, when the argument on the right of the "},{"type":"codeVoice","code":"??"},{"type":"text","text":" is also optional."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Because "},{"type":"codeVoice","code":"Success"},{"type":"text","text":" can‚Äôt change, and "},{"type":"codeVoice","code":"Failure"},{"type":"text","text":" is tied to "},{"type":"codeVoice","code":"Success"},{"type":"text","text":", for "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":", "},{"type":"codeVoice","code":"Failure"},{"type":"text","text":" can‚Äôt change either."}],"type":"paragraph"},{"code":["let characters: Optional = \"ü¶ÅüêØüêªüëßüèªüë†üêíü™Ω\"","let character: Character? = \"üßô‚Äç‚ôÄÔ∏è\"","characters?.randomElement() ?? character  \/\/ Character?"],"syntax":"swift","type":"codeListing"}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"kind":"article","variants":[{"paths":["\/documentation\/hmoptional\/mapping-methods"],"traits":[{"interfaceLanguage":"swift"}]}],"metadata":{"modules":[{"name":"HMOptional"}],"role":"article","roleHeading":"Article","title":"Mapping Methods"},"seeAlsoSections":[{"identifiers":["doc:\/\/HMOptional\/documentation\/HMOptional\/Swift\/Optional"],"generated":true}],"hierarchy":{"paths":[["doc:\/\/HMOptional\/documentation\/HMOptional"]]},"sections":[],"references":{"https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators/#Nil-Coalescing-Operator":{"url":"https:\/\/docs.swift.org\/swift-book\/documentation\/the-swift-programming-language\/basicoperators\/#Nil-Coalescing-Operator","titleInlineContent":[{"text":"nil-coalescing operator","type":"text"}],"title":"nil-coalescing operator","identifier":"https:\/\/docs.swift.org\/swift-book\/documentation\/the-swift-programming-language\/basicoperators\/#Nil-Coalescing-Operator","type":"link"},"doc://HMOptional/documentation/HMOptional":{"role":"collection","abstract":[{"type":"text","text":"Extended functionality for "},{"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/optional","isActive":true},{"text":".","type":"text"}],"type":"topic","kind":"symbol","identifier":"doc:\/\/HMOptional\/documentation\/HMOptional","url":"\/documentation\/hmoptional","title":"HMOptional"},"https://developer.apple.com/documentation/swift/optional/map(_:)":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/optional\/map(_:)","titleInlineContent":[{"code":"Optional.map","type":"codeVoice"}],"title":"Optional.map","url":"https:\/\/developer.apple.com\/documentation\/swift\/optional\/map(_:)","type":"link"},"https://github.com/Catterwaul/Thrappture":{"type":"link","identifier":"https:\/\/github.com\/Catterwaul\/Thrappture","title":"throwing property wrappers","titleInlineContent":[{"text":"throwing property wrappers","type":"text"}],"url":"https:\/\/github.com\/Catterwaul\/Thrappture"},"https://developer.apple.com/documentation/swift/optional":{"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/optional","title":"Optional","titleInlineContent":[{"type":"text","text":"Optional"}],"url":"https:\/\/developer.apple.com\/documentation\/swift\/optional"},"https://docs.swift.org/swift-book/documentation/the-swift-programming-language/optionalchaining/":{"url":"https:\/\/docs.swift.org\/swift-book\/documentation\/the-swift-programming-language\/optionalchaining\/","titleInlineContent":[{"type":"text","text":"Optional chaining"}],"title":"Optional chaining","identifier":"https:\/\/docs.swift.org\/swift-book\/documentation\/the-swift-programming-language\/optionalchaining\/","type":"link"},"https://catterwaul.github.io/HemiprocneMystaceaResult/documentation/hmresult/mapping-methods":{"type":"link","identifier":"https:\/\/catterwaul.github.io\/HemiprocneMystaceaResult\/documentation\/hmresult\/mapping-methods","title":"HemiprocneMystaceaResult","titleInlineContent":[{"text":"HemiprocneMystaceaResult","type":"text"}],"url":"https:\/\/catterwaul.github.io\/HemiprocneMystaceaResult\/documentation\/hmresult\/mapping-methods"},"https://developer.apple.com/documentation/swift/optional/flatmap(_:)":{"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/optional\/flatmap(_:)","title":"Optional.flatMap","titleInlineContent":[{"type":"codeVoice","code":"Optional.flatMap"}],"url":"https:\/\/developer.apple.com\/documentation\/swift\/optional\/flatmap(_:)"},"doc://HMOptional/documentation/HMOptional/Swift/Optional":{"kind":"symbol","type":"topic","role":"symbol","fragments":[{"text":"extension","kind":"keyword"},{"kind":"text","text":" "},{"text":"Optional","kind":"identifier","preciseIdentifier":"s:Sq"}],"url":"\/documentation\/hmoptional\/swift\/optional","abstract":[],"identifier":"doc:\/\/HMOptional\/documentation\/HMOptional\/Swift\/Optional","title":"Optional","navigatorTitle":[{"kind":"identifier","text":"Optional"}]},"https://developer.apple.com/documentation/swift/optional#Transforming-an-Optional-Value":{"url":"https:\/\/developer.apple.com\/documentation\/swift\/optional#Transforming-an-Optional-Value","titleInlineContent":[{"type":"codeVoice","code":"Optional"},{"text":" mapping","type":"text"}],"title":"Optional mapping","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/optional#Transforming-an-Optional-Value","type":"link"}}}